{
  "name": "Schedulers: FIFO vs. SJF vs. Round-Robin",
  "tagline": "Which should you choose?",
  "body": "### Problem\r\nOur project explores how the operating system uses a process scheduler by implementing three scheduling algorithms FIFO SJF and RR. The idea of scheduling has many applications outside of the operating system. This idea touches industries such as delivery, manufacturing, etc making this knowledge transferable. \r\n\r\nBy comparing the three schedulers using average turnaround time and response time, the difference between non-preemptive and preemptive schedulers can be demonstrated. \r\n\r\nThese performance metrics are calculated using the following formulas.\r\n\r\nResponse Time = Start Time - Arrival Time\r\nTurnaround Time = Completion Time - Start Time\r\n\r\n\r\n### The Good and the Ugly (Our approach to the code)\r\nThe part that we found most interesting is where we tried to simulate a multi core processor. We were interested to see how much improvement multiple cores could make. Unfortunately, we did not plan ahead for the concurrency issues that awaited us. This required us to rethink about how the code was setup. Some of the methods were handling too many tasks. Once we cleaned things up and refactored the code, we were able to isolate the insert, and getTask methods. These were significant because we felt that these two methods were the two critical sections that needed to be synchronized. Once we set the methods to synchronized, everything was back to running smoothly.\r\n\r\n### Analysis (Drum roll please)\r\n\r\n\r\nUsing multiple cores increases throughput at slightly less than linear rate.\r\n\r\n[Results](https://docs.google.com/presentation/d/1M0Bi7oSkHuiTGbbcSNbEQdPNHh2zd6Z6PUBuKw6qysY/edit#slide=id.g13d3e7b841_0_0)\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}